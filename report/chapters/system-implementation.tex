\chapter{System Implementation}

\section{Introduction} \label{s-i--introduction}

This chapter described the high-level requirements and design of a system that blah blah blah.  The chapter started by describing blah.  The proposed solution was then discussed in section blah followed by blah in section blah, etc.
Blah blah is covered in further detail in Chapter 4 which describes the implementation of blah blah.

\section{Blah blah}

% explain react

\section{Packages}

Preact, is a framework that attempts to recreate functionality of React but with the focus of performance. Using Preact means a better development experience. % cite preact

Due to the artefact's knowledge base around homebrewing, a package called Brauhaus was used. Brauhaus handles coversions of brewing recipes and brewing information. Using this package means that the homebrewing knowledge such as calculations is abstracted away, meaning developers don't neccessarily to fully understand the knowledge base to create the application. % cite Brauhaus

One principle for software development is DRY (don't repeat yourself). One principle for software development is DRY (don't repeat yourself). Developers should not be solving the same problems repeatedly, this is where having concise software to solve specific problems is needed. In the artefact a package called moment.js is used, this package handles most date and time related problems. To implement these features is not neccessarily difficult, but packages such as moment.js offer tried and tested solutions. % cite DRY and moment

\section{Development Workflow}

There are many task runners for improving a development workflow such as Gulp, Grunt and Broccoli. A technolgoy that is used in place of task runners for this artefact is Webpack. Webpack bundles all dependancies that you require, it then indexes these dependancies. This way only the dependancies you're using, which is in contrast to having to define your dependacies in task runners as previously mentioned. This results in a smaller file. % cite webpack

Recently npm is being used for front-end dependancies aswell as back-end dependanices. This seems odd as npm is usually for node, but makes sense when using Webpack, Browserify to bundle your files. Managers such as bower which dedicated itself to front-end dependencies has seen a drop in usage due to this. % cite browserify, bower

% commitzen

\section{Data and Databases}

The artefact syncs a remote CouchDB database to the local PouchDB and then Preact fetches the local database into memory as part of the state.

As previously mentioned CouchDB is excellent at master-to-master replication of databases. This means syncing is easily implemented:

% insert diagram here

The remote database and the local databases sync any changes between themselves, when the local database changes the recipes and brews in state are updated.

CouchDB has a user authentication system for handling permission and roles to documents. By default everyone is an admin in waht they describe as the `admin party', this is recommended to be disabled but aids development with low barrier to entry when starting a new project.

This authentication system has been leveraged for a simplistic user system for the application. Due to the data defining most of the application, this solution could be achieved through a Express, Passport etc solution.

% service worker offline cache setup, push notifs

\section{Continous Integration and Deployment}

As ThoughtWorks describes ``Continuous Integration (CI) is a development practice that requires developers to integrate code into a shared repository several times a day. Each check-in is then verified by an automated build, allowing teams to detect problems early.". % cite https://www.thoughtworks.com/continuous-integration

There are different ways to achieve CI, the artefact is using Travis CI. Travis CI is a online software-as-a-service CI platform. It allows developers to define a set of tasks to carry out (through a `.travis.yml` file in the repository). These tasks should have a success and fail conditions for Travis to know the status of a build. Exampels of tasks include buidling from dependanices and running tests.

Another usage of CI is through the ShareLatex CI which handles the rendering of this very report! This report was created using \LaTeX a word processing and document markup languages. Other languages such as Markdown could have been used however \LaTeX is a better fit for academic writing. As these files are inside the project repository the ShareLatex CI is triggured on push to the GitHub repository building the final PDF each time.  % cite latex

The deployment is also triggered by these tests succeeding, ensuring unstable builds of the application are never deployed.

Surge (surge.sh) is being used to deploy, it is command-line tool that allows for simple deployment. Installed through npm, it removes any need for FTP, SSH or other more complicated deployment set-ups. Obviously this has limitiations, but for front-end web applications this is a simple and effective option. % cite surge

This CI is triggered by pushing to the GitHub repository. This allows for both the code, the tests and deployment to all be together.

\section{Interesting Problems} \label{s-i--interesting-problems}

During the project implementation several issues were identified that merit discussion. This section addresses those topics, which are blah, blah and blah.

% service worker development workflow

% push notifications forced the usage of a microservice server due to the GCM
When registering a user for push notifications there are some best practises in terms of UX.

Signing up a user with no context is strongly discouraged, the user should always know what they've signed up for through an action. Giving the user even more control by being able to toggle the notifications after initially registering is recommended. \cite{best_practises_push_notifications}

% using newer tech such as webpack, preact etc lead to difficulties. lack of support etc. preact soundcloud thing

% lack of knowledge meant a strong dependancy on the brauhaus.js package for recipe converstions etc. this dependancy could be removed in future

\section{Summary} \label{s-i--summary}

This chapter described the implementation of blah blah, which was based on the design described in Chapter 3. The implementation was introduced in section x and blah blah blah. Once the general implementation details had been introduced, several interesting implementation problems were addressed in section q, including the detailed coverage of blah blah.

\section{Testing and Evaluation} \label{s-i--testing-and-evaluation}

\subsection{Introduction}

Chapters 3 and 4 described the design and implementation of blah blah, a system that blah blah blah.  In this chapter, we present a testing method and its results that show blah blah blah.  The chapter is organised as follows:  Section x introduces blah and describes blah.  Next, section y presents blah, etc.
The results of the tests are summarised in section z, before the solution is evaluated in section qqq.
Write what you did, why you did it and how you did it here.

\subsection{Testing Summary}

In total over n tests were executed. Each test was blah blah blah, and this data was then used to blah. The tests illustrate that blah blah. In the next section, this is evaluated and the extent to which it supports the thesis is discussed.

% travis, tape, jsdom

% use of psi, and webpagetest to evaluate performance budget

\section{Evaluation}

Chapter 1 highlighted the problem of blah blah blah. Chapter 2 reviewed the state-of-the-art in blah and blah.  Chapter 3 identified a set of technical requirements underpinning the development of blah, and the implementation of a blah blah was described in Chapter 4.

The testing described in section x demonstrates that blah blah blah. In this section therefore, we evaluate the implementation and discuss issues in the underlying technologies that the implementation has highlighted.

    \subsection{Requirements Review} \label{s-i--requirements-review}

    This section reviews the implemented platform, referring back to the requirements to identify the extent to which each has been fulfilled, and reflecting on their relevance for future work. Each of the requirements is reintroduced and discussed in turn.
    Refer back to each specified requirement and discuss...


    \subsection{Artefact Review} \label{s-i--artefact-review}

    This section reviews the implemented platform, referring back to the requirements to identify the extent to which each has been fulfilled, and reflecting on their relevance for future work. Each of the requirements is reintroduced and discussed in turn.
    Refer back to each specified requirement and discuss...

\section{Testing and Evaluation Summary}

This chapter introduced blah and blah.  In section x a series of tests were described which demonstrated blah blah.
An evaluation of blah blah was then presented in section y.  Section z revisited the requirements described in Chapter 3 and identified that blah blah blah. Finally in section q the aspects of blah blah were discussed.
